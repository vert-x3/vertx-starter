{
  "defaults": {
    "groupId": "com.example",
    "artifactId": "starter",
    "language": "java",
    "buildTool": "maven",
    "vertxVersion": "3.9.0",
    "archiveFormat": "zip",
    "jdkVersion": "1.8"
  },
  "versions": [
    {
      "number": "3.9.0",
      "exclusions": []
    },
    {
      "number": "3.8.5",
      "exclusions": []
    },
    {
      "number": "4.0.0-milestone4",
      "exclusions": []
    },
    {
      "number": "4.0.0-SNAPSHOT",
      "exclusions": []
    }
  ],
  "stack": [
    {
      "code": "web",
      "category": "Web",
      "items": [
        {
          "artifactId": "vertx-web",
          "name": "Vert.x Web",
          "description": "Vert.x-Web is a tool-kit for writing sophisticated modern web applications and HTTP microservices."
        },
        {
          "artifactId": "vertx-web-client",
          "name": "Vert.x Web Client",
          "description": "Vert.x Web Client is an easy to use advanced HTTP client."
        },
        {
          "artifactId": "vertx-web-graphql",
          "name": "Web GraphQL Handler",
          "description": "Create GraphQL servers with Vert.x Web and the GraphQL-Java library."
        },
        {
          "artifactId": "vertx-web-api-contract",
          "name": "Web API Contract",
          "description": "Web API Contract supports OpenApi 3 specification for a design first approach and provides a validation framework."
        }
      ]
    },
    {
      "code": "dataaccess",
      "category": "Data Access",
      "description": "Vert.x provides a few different asynchronous clients for accessing various data stores from your application. You don't have to use these clients - you could use clients direct from the vendor if you prefer (e.g. MongoDB provide their own cool async and reactive clients), but these provide a simple async API which is available in various languages.",
      "items": [
        {
          "artifactId": "vertx-pg-client",
          "name": "Reactive PostgreSQL client"
        },
        {
          "artifactId": "vertx-mysql-client",
          "name": "Reactive MySQL client"
        },
        {
          "artifactId": "vertx-mongo-client",
          "name": "MongoDB client"
        },
        {
          "artifactId": "vertx-jdbc-client",
          "name": "JDBC client"
        },
        {
          "artifactId": "vertx-redis-client",
          "name": "Redis client"
        },
        {
          "artifactId": "vertx-cassandra-client",
          "name": "Cassandra client"
        }
      ]
    },
    {
      "code": "reactive",
      "category": "Reactive",
      "description": "Vert.x provides a few components to make your applications more reactive.",
      "items": [
        {
          "artifactId": "vertx-rx-java",
          "name": "Vert.x RxJava v1",
          "description": "Don't like callback-style APIs? Vert.x provides Rx-ified (using RxJava) versions for most of its APIs so you can use those if you prefer. RxJava is a great choice when you want to perform complex operations on multiple asynchronous streams of data."
        },
        {
          "artifactId": "vertx-rx-java2",
          "name": "Vert.x RxJava v2",
          "description": "Don't like callback-style APIs? Vert.x provides Rx-ified (using RxJava) versions for most of its APIs so you can use those if you prefer. RxJava is a great choice when you want to perform complex operations on multiple asynchronous streams of data."
        },
        {
          "artifactId": "vertx-reactive-streams",
          "name": "Reactive streams",
          "description": "Vert.x supports reactive streams so your applications can interoperate with other reactive systems such as Akka or Project Reactor."
        },
        {
          "artifactId": "vertx-sync",
          "name": "Vert.x Sync",
          "description": "Vertx-sync allows you to deploy verticles that run using fibers. Fibers are very lightweight threads that can be blocked without blocking a kernel thread. This enables you to write your verticle code in a familiar synchronous style."
        },
        {
          "artifactId": "vertx-lang-kotlin-coroutines",
          "name": "Vert.x Kotlin coroutines",
          "description": "Kotlin coroutines for Vert.x, gives you super powers such as async/await or Go-like channels. This enables you to write your verticle code in a familiar sequential style."
        }
      ]
    },
    {
      "code": "microservices",
      "category": "Microservices",
      "description": "Vert.x offers various component to build microservice-based applications.",
      "items": [
        {
          "artifactId": "vertx-service-discovery",
          "name": "Vert.x Service Discovery",
          "description": "This component lets you publish, lookup and bind to any type of services."
        },
        {
          "artifactId": "vertx-circuit-breaker",
          "name": "Vert.x Circuit Breaker",
          "description": "This component provides an implementation of the circuit breaker pattern for Vert.x"
        },
        {
          "artifactId": "vertx-config",
          "name": "Vert.x Config",
          "description": "This component provides an extensible way to configure Vert.x applications."
        }
      ]
    },
    {
      "code": "iot",
      "category": "IoT",
      "items": [
        {
          "artifactId": "vertx-mqtt",
          "name": "MQTT",
          "description": "Vert.x MQTT (client and server) is able to handle connections, communication and messages exchange with remote MQTT clients. Its API provides a bunch of events related to protocol messages received by clients and exposes allow to send messages to them."
        }
      ]
    },
    {
      "code": "auth",
      "category": "Authentication and Authorisation",
      "description": "Vert.x provides simple APIs for auth in your applications. We also provide a few out of the box implementations.",
      "items": [
        {
          "artifactId": "vertx-auth-jdbc",
          "name": "JDBC auth",
          "description": "Auth implementation backed by JDBC"
        },
        {
          "artifactId": "vertx-auth-jwt",
          "name": "JWT auth",
          "description": "Auth implementation using JSON web tokens (JWT)"
        },
        {
          "artifactId": "vertx-auth-shiro",
          "name": "Shiro auth",
          "description": "Auth implementation using Apache Shiro"
        },
        {
          "artifactId": "vertx-auth-mongo",
          "name": "MongoDB auth",
          "description": "Auth implementation using MongoDB"
        },
        {
          "artifactId": "vertx-auth-oauth2",
          "name": "OAuth 2",
          "description": "Auth implementation for OAuth2"
        },
        {
          "artifactId": "vertx-auth-htdigest",
          "name": ".htdigest Auth",
          "description": ".htdigest file to query user information"
        }
      ]
    },
    {
      "code": "messaging",
      "category": "Messaging",
      "items": [
        {
          "artifactId": "vertx-amqp-client",
          "name": "AMQP Client",
          "description": "A client for interacting with an AMQP 1.0 broker or router."
        },
        {
          "artifactId": "vertx-stomp",
          "name": "STOMP Client and Server",
          "description": "Vert.x provides an implementation of the STOMP protocol."
        },
        {
          "artifactId": "vertx-rabbitmq-client",
          "name": "RabbitMQ Client",
          "description": "A client to interact with RabbitMQ."
        },
        {
          "artifactId": "vertx-amqp-bridge",
          "name": "AMQP Bridge",
          "description": "A bridge for interacting with an AMQP 1.0 broker or router."
        }
      ]
    },
    {
      "code": "integration",
      "category": "Integration",
      "items": [
        {
          "artifactId": "vertx-mail-client",
          "name": "Mail Client",
          "description": "Vert.x provides a simple SMTP mail client so you can send emails from your applications."
        },
        {
          "artifactId": "vertx-jca",
          "name": "JCA Adaptor",
          "description": "Vert.x provides a Java Connector Architecture (JCA) adaptor which allows it to interoperate with any JavaEE application server."
        },
        {
          "artifactId": "vertx-kafka-client",
          "name": "Kafka Client",
          "description": "A client to interact with Apache Kafka."
        },
        {
          "artifactId": "vertx-consul-client",
          "name": "Consul Client",
          "description": "A client to interact with Consul."
        }
      ]
    },
    {
      "code": "eventbus",
      "category": "Event Bus Bridge",
      "description": "Vert.x offers various bridges to extend the Event Bus beyond the JVM",
      "items": [
        {
          "artifactId": "vertx-tcp-eventbus-bridge",
          "name": "TCP Eventbus Bridge",
          "description": "An eventbus bridge that lets you interact with Vert.x from any application thanks to a TCP socket."
        },
        {
          "artifactId": "vertx-camel-bridge",
          "name": "Camel Bridge",
          "description": "An eventbus bridge that lets you interact with Apache Camel endpoints and routes"
        }
      ]
    },
    {
      "code": "devops",
      "category": "DevOps",
      "description": "Vert.x offers various component to keep your Vert.x application on track when running in production",
      "items": [
        {
          "artifactId": "vertx-dropwizard-metrics",
          "name": "Metrics using Dropwizard",
          "description": "This component captures metrics from Vert.x core components and exposes them using Dropwizard."
        },
        {
          "artifactId": "vertx-micrometer-metrics",
          "name": "Metrics using Micrometer",
          "description": "This component captures metrics from Vert.x core components and exposes them using Micrometer."
        },
        {
          "artifactId": "vertx-health-check",
          "name": "Vert.x Health Check",
          "description": "This component provides a simple way to expose health checks."
        },
        {
          "artifactId": "vertx-shell",
          "name": "Shell",
          "description": "This component lets you interact with your Vert.x application using a CLI interface."
        }
      ]
    },
    {
      "code": "testing",
      "category": "Testing",
      "description": "Vert.x-Unit is an unit testing tool-kit especially design to work well with asynchronous code.",
      "items": [
        {
          "name": "Vert.x Unit",
          "artifactId": "vertx-unit"
        },
        {
          "name": "Vert.x JUnit5",
          "artifactId": "vertx-junit5"
        }
      ]
    },
    {
      "code": "cluster",
      "category": "Clustering",
      "description": "Vert.x supports clustering and HA out of the box. Cluster group management is implemented in cluster managers which are pluggable. The default cluster manager uses Hazelcast.",
      "items": [
        {
          "name": "Hazelcast",
          "artifactId": "vertx-hazelcast",
          "description": "Cluster manager implementation that uses Hazelcast. This is the default."
        },
        {
          "name": "Infinispan",
          "artifactId": "vertx-infinispan",
          "description": "Cluster manager implementation that uses Infinispan."
        },
        {
          "name": "Apache Ignite",
          "artifactId": "vertx-ignite",
          "description": "Cluster manager implementation that uses Apache Ignite."
        },
        {
          "name": "Apache Zookeper",
          "artifactId": "vertx-zookeeper",
          "description": "Cluster manager implementation that uses Apache Zookeeper."
        }
      ]
    },
    {
      "code": "services",
      "category": "Services",
      "description": "Vert.x services are a simple and effective way to encapsulate reusable functionality for use elsewhere. Services are deployed using a service identifier which decouples the user from details of the implementation.",
      "items": [
        {
          "name": "Service Proxies",
          "artifactId": "vertx-service-proxy",
          "description": "Proxies allow remote event bus services to be called as if they were local."
        },
        {
          "name": "SockJS Service Proxies",
          "artifactId": "vertx-sockjs-service-proxy",
          "description": "Allow event bus services to be called from JavaScript (browser or Node.js)."
        },
        {
          "name": "gRPC",
          "artifactId": "vertx-grpc",
          "description": "Implement gRPC Clients and Servers for Vert.x."
        },
        {
          "name": "Service Factories",
          "artifactId": "vertx-service-factory",
          "description": "How to package and deploy Vert.x independent services."
        },
        {
          "name": "Maven Service Factory",
          "artifactId": "vertx-maven-service-factory",
          "description": "This lets you dynamically install and deploy services from Maven at run-time."
        },
        {
          "name": "HTTP Service Factory",
          "artifactId": "vertx-http-service-factory",
          "description": "This lets you dynamically install and deploy services from an HTTP server (for example Bintray at run-time."
        }
      ]
    }
  ]
}
